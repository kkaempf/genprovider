#
# testcase.rb
#

module Genprovider
  class Testcase
    # return Ruby type equivalent
    def rubytype type
      case type.to_sym
      when :boolean then return ""
      when :string then return "String"
      when :char16 then return "Integer"
      when :uint8 then return "Integer"
      when :uint16 then return "Integer"
      when :uint32 then return "Integer"
      when :uint64 then return "Integer"
      when :sint8 then return "Integer"
      when :sint16 then return "Integer"
      when :sint32 then return "Integer"
      when :sint64 then return "Integer"
      when :real32 then return "Float"
      when :real64 then return "Float"
      when :dateTime then return "Time"
      when :reference then return "Sfcc::Cim::ObjectPath"
      when :class then return "Sfcc::Cim::Class"
      else
        STDERR.puts "Unhandled type #{type}"
      end
    end
    
    def initialize c, namespace, out
      out.comment.comment "Testcase for #{namespace}:#{c.name}"
      out.comment.comment "Generated by 'genprovider' for use with cmpi-bindings-ruby"
      out.puts "require 'rubygems'"
      out.puts "require 'sfcc'"
      out.puts "require 'test/unit'"
      out.puts
      out.puts "class Test_#{c.name} < Test::Unit::TestCase"
      out.inc
      out.def "setup"
      out.puts "@client = Sfcc::Cim::Client.connect(:uri => 'http://localhost:12345', :verify => false)"
      out.puts "@op = Sfcc::Cim::ObjectPath.new('#{namespace}', '#{c.name}')"
      out.end
      out.puts
      out.def "test_registered"
      out.puts "cimclass = @client.get_class(@op)"
      out.puts "assert cimclass"
      out.end # test_registered
      out.puts
      out.def "test_instance_names"
      out.puts "names = @client.instance_names(@op)"
      out.puts "assert names.size > 0"
      out.puts "names.each do |ref|"
      out.inc
      out.puts "ref.namespace = @op.namespace"
      out.puts "instance = @client.get_instance ref"
      out.puts "assert instance"
      out.puts
      #
      # Properties
      #
      c.features.each do |p|
        next unless p.property?
        element = "instance.#{p.name}"
        out.puts "assert #{element}"
        if p.type.array?
          out.puts "assert_kind_of Array, #{element} # #{p.type}"
          out.puts "tmp = #{element}[0]"
          element = "tmp"
        end
        rtype = rubytype p.type
        raise "Unsupported type #{p.type} [#{rtype.class}]" if rtype.nil?
        out.puts "if #{element}"
        out.inc
        if rtype.empty?
          out.puts "assert #{element}.is_a?(TrueClass) || #{element}.is_a?(FalseClass)"
        else
          out.puts "assert_kind_of #{rubytype p.type}, #{element} # #{p.type}"
        end
        out.end
      end
      out.end #     names.each
      out.end #   test_instance_names
      #
      # References
      #
      out.puts
      c.features.each do |r|
        next unless r.reference?
      end
      #
      # Methods
      #
      out.puts
      c.features.each do |m|
        next unless m.method?
        out.puts
        out.def "test_method_#{m.name}"
        if m.static?
          # class-level method
        else
          # instance level method
          out.puts "@client.instances(@op).each do |inst|"
          out.inc
          m.parameters.each do |p|
            desc = p.description
            out.comment desc if desc
            if p.out?
              out.puts "p_out_#{p.name} = {} # #{p.type}"
            else
              out.puts "p_in_#{p.name} = nil # #{p.type}"
            end
          end
          s = "res = inst.#{m.name}("
          first = true
          m.parameters.each do |p|
            if first
              first = false
            else
              s << ", "
            end
            if p.includes? :out
              s << "p_out_#{p.name}"
            else
              s << "p_in_#{p.name}"
            end
          end
          s << ")"
          out.puts s
          out.puts "assert_kind_of #{rubytype m.type}, res"
          out.end
        end
        out.end # test_method_<name>
      end
      out.puts
      out.end # class
    end
  end
end
