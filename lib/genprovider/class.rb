#
# Genprovider::Class
#

#
# make element description
#

module Genprovider
  class Class
    def self.mkdescription out, element
      p = element.qualifiers["description", :string]
      out.comment
      out.comment(p.value).comment if p
    end

    def self.keyargs c, out, first = true
      keyargs c.parent, first, out if c.parent
      c.each_key do |k|
	if first
	  first = false
	else
	  out.write ", "
	end
	out.write(k.name.decamelize)
      end
    end

    #
    # make initializer
    #

    def mkinitialize c, out

      out.def "initialize", "reference", "properties"
      if c.parent
	out.puts "super reference,properties"
      end
      out.end
    end

    #
    # make static methods
    #

    def mkstatic c, out
      out.comment "each_name: yield references with sufficient information to retrieve instances"
      out.def "self.each_name", "reference", "properties = nil" 
      out.comment "Retrieve names, adapt reference, and yield CMPIObjectPath"
      out.comment
      out.comment "YOUR CODE HERE"
      out.comment
      out.end
      out.comment "each: yield references with full information to create instances"
      out.def "self.each", "reference", "properties = nil" 
      out.comment "Retrieve names, adapt reference, and yield CMPIObjectPath"
      out.comment
      out.comment "YOUR CODE HERE"
      out.comment
      out.end
      out.def "self.delete", "reference", "properties = nil"
      out.comment "Remove by reference"
      out.comment
      out.comment "YOUR CODE HERE"
      out.comment
      out.end
    end

    #
    # make feature definition
    #

    def mkdef out, feature
      Genprovider::Class.mkdescription out, feature
      case feature
      when CIM::Property:
      # skip
      when CIM::Reference: out.comment "Reference"
      when CIM::Method: out.comment "Method"
      else
	raise "Unknown feature class #{feature.class}"
      end
      out.comment feature.type.to_s + " : " + feature.name
      out.comment "*Key*" if feature.key?
      out.comment
      
      args = nil      
      if feature.method?
	feature.parameters.each do |p|
	  args ||= []
	  if p.qualifiers.include?(:out,:bool)
	    args << "#{p.name.decamelize}_out"
	  else
	    args << p.name.decamelize
	  end
	end
      end
      n = feature.name.decamelize
      out.def n, args
        out.puts "@#{n}"
      out.end
      if feature.property? && feature.qualifiers.include?(:write)
	out.def "#{n}=", "_arg" 
          out.puts "@#{n} = _arg"
	out.end
      end
    end
      
    #
    # generate code for property
    #
      
    def mkproperty property, out
      mkdef out, property
    end

    #
    # generate code for reference
    #
      
    def mkreference reference, out
      mkdef out, reference
    end
    
    #
    # generate code for method
    #
    
    def mkmethod method, out
      mkdef out, method
    end
    
    #
    # generate provider code for features matching match
    #
    
    def mkfeatures features, out, match
      features.each do |f|
	next unless f.instance_of? match
	case f
	when CIM::Property: mkproperty f, out
	when CIM::Reference: mkreference f, out
	when CIM::Method: mkmethod f, out
	else
	  raise "Unknown feature class #{f.class}"
	end
      end
    end
    
    #
    # generate provider code for class 'c'
    #
    
    def initialize c, out
      out.comment
      out.comment "Generated by genprovider"
      out.comment
      out.puts("require 'cmpi'").puts
      out.puts("module Cmpi").inc
      
      Genprovider::Class.mkdescription out, c
      
      if c.superclass
	out.puts "d = File.dirname(__FILE__)"
	out.puts "$: << d unless $:.include? d"
	out.puts "require '#{c.superclass.decamelize}'"
      end
      out.comment.comment "Key properties:"
      k = c
      while k
	k.features.each do |f|
	  next unless f.key?
	  out.comment "- #{f.type} #{f.name} (-> #{k.name})"
	end
	k = k.parent
      end
      out.comment
      out.printf("class #{c.name}")
      out.write(" < #{c.superclass}") if c.superclass
      out.puts.inc
      # class functions
      mkstatic c, out
      # initializer
      mkinitialize c, out
      # normal properties
      mkfeatures c.features, out, CIM::Property
      # reference properties
      mkfeatures c.features, out, CIM::Reference
      # methods
      mkfeatures c.features, out, CIM::Method
      out.end # class
      out.end # module
    end
  end
end
