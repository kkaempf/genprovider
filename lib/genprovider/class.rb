#
# Genprovider::Class
#

#
# make element description
#

module Genprovider
  class Class
    def self.mkdescription out, element
      p = element.qualifiers["description", :string]
      out.comment
      out.comment(p.value).comment if p
    end

    def self.keyargs c, out, first = true
      keyargs c.parent, first, out if c.parent
      c.each_key do |k|
	if first
	  first = false
	else
	  out.write ","
	end
	out.write(" ").write(k.name.decamelize)
      end
    end

    #
    # make initializer
    #

    def mkinitialize c, out

      out.comment.comment "Key properties:"
      c.features.each do |f|
	next unless f.key?
	out.comment "- #{f.type} #{f.name}"
      end
      out.comment
      out.printf "def initialize("
				 Genprovider::Class.keyargs c, out
				 out.puts(")").inc
      if c.parent
	out.printf "super("
	Genprovider::Class.keyargs c.parent, out
	out.puts ")"
      end
      out.dec.puts("end")
    end

    #
    # make feature definition
    #

    def mkdef out, feature
      case feature
      when CIM::Property:
      # skip
      when CIM::Reference: out.comment "Reference"
      when CIM::Method: out.comment "Method"
      else
	raise "Unknown feature class #{feature.class}"
      end
      Genprovider::Class.mkdescription out, feature
      #  puts feature.name
      
      out.printf "def %s", feature.name.decamelize
      if feature.method?
	out.write " ("
	first = true
	feature.parameters.each do |p|
	  if first
	    first = false
	  else
	    out.write ", "
	  end
	  out.write p.name
	  out.write "_out" if p.qualifiers.include?(:out,:bool)
	end
	out.write ")"
      end
      out.puts.inc
    end
      
    #
    # generate code for property
    #
      
    def mkproperty property, out
      mkdef out, property
      out.dec.puts("end")
    end

    #
    # generate code for reference
    #
      
    def mkreference reference, out
      mkdef out, reference
      out.dec.puts("end")
    end
    
    #
    # generate code for method
    #
    
    def mkmethod method, out
      mkdef out, method
      out.dec.puts("end")
    end
    
    #
    # generate provider code for features matching match
    #
    
    def mkfeatures features, out, match
      features.each do |f|
	next unless f.instance_of? match
	case f
	when CIM::Property: mkproperty f, out
	when CIM::Reference: mkreference f, out
	when CIM::Method: mkmethod f, out
	else
	  raise "Unknown feature class #{f.class}"
	end
      end
    end
    
    #
    # generate provider code for class 'c'
    #
    
    def initialize c, out
      out.comment
      out.comment "Generated by genprovider"
      out.comment
      out.puts("require 'cmpi'").puts
      out.puts("module Cmpi").inc
      
      Genprovider::Class.mkdescription out, c
      
      if c.superclass
	out.puts "$: << '#{out.dir}'"
	out.puts "require '#{c.superclass.decamelize}'"
      end
      out.printf("class #{c.name}")
      out.write(" < #{c.superclass}") if c.superclass
      out.puts.inc
      # initializer
      mkinitialize c, out
      # normal properties
      mkfeatures c.features, out, CIM::Property
      # reference properties
      mkfeatures c.features, out, CIM::Reference
      # methods
      mkfeatures c.features, out, CIM::Method
      out.dec.puts "end" # class
      out.dec.puts "end" # module
    end
  end
end
